{"version":3,"sources":["components/Input.tsx","components/Step.tsx","components/Description.tsx","solve.ts","components/Solver.tsx","components/App.tsx","index.tsx"],"names":["Input","value","onChange","className","type","event","Step","initial","Description","tokenizeLiteral","literal","includes","isNaN","parseFloat","parseInt","resolveNegatives","tokens","newTokens","i","length","push","nextToken","performSimpleOperation","tokenValues","map","token","operators","operatorIndex","indexOf","newToken","undefined","leftOperand","rightOperand","operator","newType","newValue","Math","pow","leftTokens","slice","rightTokens","concat","performOperation","parenStart","parenEnd","contents","contentsOperated","evaluate","text","charAt","j","tokenize","isNegative","establishNegatives","steps","Solver","React","useState","expression","setExpression","target","console","log","forEach","step","formatted","toString","join","split","formatTokens","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.fc07a386.chunk.js","sourcesContent":["import React from 'react';\nimport '../styles/Input.css';\n\ntype InputProps = {\n  value: string,\n  onChange: (event: React.ChangeEvent<HTMLInputElement>) => void\n}\n\nconst Input = ({ value, onChange }: InputProps) => {\n  return (\n    <div className='input'>\n      <input\n        type='text'\n        value={value}\n        onChange={(event: React.ChangeEvent<HTMLInputElement>): void => onChange(event)}\n      />\n    </div>\n  );\n};\n\nexport default Input;\n","import React from 'react';\nimport '../styles/Step.css';\n\ntype StepProps = {\n  initial?: boolean,\n}\nconst Step = ({ initial }: StepProps) => {\n  return (\n    <div className={initial ? 'step step-initial' : 'step step-next'}>\n    </div>\n  );\n};\n\nexport default Step;\n","import React from 'react';\nimport '../styles/Description.css';\n\nconst Description = () => {\n  return (\n    <div className='description'>\n    </div>\n  );\n};\n\nexport default Description;\n","// import { exception } from \"console\";\n\nconst formatTokens = (tokens: Token[]): string => {\n  let formatted = tokens.map((token) => token.value.toString()).join(' ')\n  formatted = formatted.split('neg (').join('- (')\n  return formatted\n}\n\ntype TokenType = 'operator' | 'integer' | 'float';\n// TODO: Figure out how to use TokenValue alias without causing problems.\n  // Problem: 'Type \"string\" is not assignable to type \"TokenValue\"'\n// type TokenValue = '(' | ')' | '^' | 'neg' | '*' | '/' | '+' | '-' | number;\ntype TokenValue = string | number;\ntype Token = {\n  type: TokenType,\n  value: TokenValue\n};\n\nconst tokenizeLiteral = (literal: string): Token | undefined => {\n  if (literal.includes('.')) {\n    if (isNaN(parseFloat(literal))) {\n      // raise Exception('User Error: Solitary \".\" is not a valid literal.')\n      return undefined\n    } else {\n      return {type: 'float', value: parseFloat(literal)};\n    }\n  } else if (!isNaN(parseInt(literal))) {\n    return {type: 'integer', value: parseInt(literal)};\n  } else {\n    // raise Exception('User Error: Literal not recognized.')\n    return undefined\n  }\n};\n\nconst tokenize = (text: string): Token[] | undefined => {\n  let tokens: Token[] = [];\n  for (let i=0; i < text.length; i++) {\n    // Char at i is a number or \".\"\n    if (!isNaN(parseInt(text.charAt(i))) || text.charAt(i) === '.') {\n      let j = i;\n      while (j < text.length && (!isNaN(parseInt(text.charAt(j))) || text.charAt(j) === '.')) {\n        j += 1;\n      }\n      const literal = text.slice(i, j);\n      const token = tokenizeLiteral(literal);\n      if (token) {\n        tokens.push(token);\n        i = j-1;\n      } else {\n        // Internal Error: tokenize literal returned undefined.\n        return undefined;\n      }\n    } else if (['(', ')', '^', '*', '/', '+', '-'].includes(text.charAt(i))) {\n      const token: Token = {type: 'operator', value: text.charAt(i)}\n      tokens.push(token);\n    } else if (text.charAt(i) !== ' ') {\n      // raise Exception('User Error: \"' + text[i] + '\" is not a valid character.')\n      return undefined;\n    }\n  }\n  return tokens;\n};\n\n// NOT intended to handle errors.\nconst establishNegatives = (tokens: Token[]): Token[] => {\n  let newTokens: Token[] = [];\n  for (let i=0; i < tokens.length; i++) {\n    // Is a candidate for conversion to \"neg\".\n    if (tokens[i].value === '-') {\n      let isNegative = true;\n      // Minus is at the end.\n      if (i+1 === tokens.length) {\n        isNegative = false;\n      // Minus is followed by an operator other than \"(\".\n      } else if (tokens[i+1].type === 'operator' && tokens[i+1].value !== '(') {\n        isNegative = false;\n      // Minus follows a number.\n      } else if (i > 0 && ['integer', 'float'].includes(tokens[i-1].type)) {\n        isNegative = false;\n      // Minus is followed by a number followed by an exponent sign (which operates before negative conversion).\n      } else if (i+2 < tokens.length && tokens[i+2].value === '^') {\n        isNegative = false\n      }\n\n      if (isNegative) {\n        newTokens.push({type: 'operator', value: 'neg'})\n      } else {\n        newTokens.push({type: 'operator', value: '-'})\n      }\n    // Not a candidate for conversion for \"neg\".\n    } else {\n      newTokens.push({type: tokens[i].type, value: tokens[i].value})\n    }\n  }\n  return newTokens;\n};\n\n// Only handles errors related to bad \"neg\"s.\nconst resolveNegatives = (tokens: Token[]): Token[] | undefined => {\n  let newTokens: Token[] = [];\n  for (let i=0; i<tokens.length; i++) {\n    if (tokens[i].value === 'neg') {\n      // Is at the end of expression (internal because it shouldn't have been converted if at end).\n      if (i+1 >= tokens.length) {\n        // raise Exception('Internal Error: Expression cannot end with a \"neg\".')\n        return undefined\n      // Is followed by \"(\".\n      } else if (tokens[i+1].value === '(') {\n        newTokens.push({type: 'operator', value: 'neg'});\n      // Is followed by a number.\n      } else if (['integer', 'float'].includes(tokens[i+1].type)) {\n        // Doing this to narrow tokens[i+1].value type.\n        const nextToken = tokens[i+1];\n        if (typeof nextToken.value === 'number') {\n          newTokens.push({type: nextToken.type, value: -1*nextToken.value});\n        } // Else something has gone terribly wrong...\n        i += 1;\n      // Is followed by something other than \"(\" or a number (internal because shouldn't have been converted if so).\n      } else {\n        // raise Exception('Internal Error: \"Neg\"s must be followed by \"(\" or a number.')\n        return undefined\n      }\n    } else {\n      newTokens.push({type: tokens[i].type, value: tokens[i].value});\n    }\n  }\n  return newTokens;\n};\n\n// Assumes no \"neg\"s or parentheses.\nconst performSimpleOperation = (tokens: Token[]): Token[] | undefined => {\n  if (tokens.length === 1) {\n    if (tokens[0].type === 'operator') {\n      // User Error: Expression cannot consist of an operator. (or something)\n      return undefined\n    } else {\n      return [{type: tokens[0].type, value: tokens[0].value}]; \n    }\n  }\n\n  const tokenValues: TokenValue[] = tokens.map((token) => token.value);\n  const operators = ['^', '*', '/', '+', '-'];\n  let operatorIndex = -1;\n  for (let i=0; i<operators.length; i++) {\n    if (tokenValues.includes(operators[i])) {\n      operatorIndex = tokenValues.indexOf(operators[i]);\n      break;\n    };\n  };\n\n  if (operatorIndex === -1) {\n    // raise Exception('User Error: Multiple tokens in expression with no operator.')\n    return undefined;\n  } else if (operatorIndex === 0) {\n    // raise Exception('User Error: Expression cannot start with operator.')\n    return undefined;\n  } else if (operatorIndex === tokens.length-1) {\n    // raise Exception('User Error: Expression cannot end with an operator.')\n    return undefined;\n  }\n  \n  let newToken: Token | undefined = undefined;\n\n  const leftOperand: Token = tokens[operatorIndex-1];\n  const rightOperand: Token = tokens[operatorIndex+1];\n  const operator: Token = tokens[operatorIndex];\n  if (typeof leftOperand.value === 'number' && typeof rightOperand.value === 'number') {\n    let newType: TokenType = 'integer';\n    if (leftOperand.type === 'float' || rightOperand.type === 'float') {\n      newType = 'float';\n    }\n    let newValue: number | undefined = undefined;\n    if (operator.value === '^') {\n      newValue = Math.pow(leftOperand.value, rightOperand.value);\n    } else if (operator.value === '*') {\n      newValue = leftOperand.value*rightOperand.value;\n    } else if (operator.value === '/') {\n      newValue = leftOperand.value/rightOperand.value;\n    } else if (operator.value === '+') {\n      newValue = leftOperand.value+rightOperand.value;\n    } else if (operator.value === '-') {\n      newValue = leftOperand.value-rightOperand.value;\n    }\n    if (newValue === undefined) {\n      // raise exception('Internal Error: \"' + operator['value'] + '\" operator not recognized.')\n      return undefined;\n    } else {\n      newToken = {type: newType, value: newValue};\n    }\n  } else {\n    // raise Exception('User Error: \"' + tokens[i]['value'] + '\" operator requires numeric operands.')\n    return undefined;\n  }\n  \n  if (newToken === undefined) {\n    // Internal Error: simple operation failed.\n    return undefined;\n  } else {\n    const leftTokens = tokens.slice(0, operatorIndex-1).map((token) => ({type: token.type, value: token.value}));\n    const rightTokens = tokens.slice(operatorIndex+2).map((token) => ({type: token.type, value: token.value}));\n    const newTokens = leftTokens.concat([newToken]).concat(rightTokens);      \n    return newTokens;\n  }\n};\n\nconst performOperation = (tokens: Token[]): Token[] | undefined => {\n  let parenStart: number | undefined = undefined;\n  let parenEnd: number | undefined = undefined;\n  for (let i=0; i<tokens.length; i++) {\n    if (tokens[i].value === '(') {\n      parenStart = i;\n    } else if (tokens[i].value === ')') {\n      parenEnd = i;\n      break;\n    }\n  }\n\n  if ((parenStart === undefined) !== (parenEnd === undefined)) {\n    // User Error: Mismatched parentheses. (or something)\n    return undefined;\n  }\n\n  let newTokens: Token[] | undefined = undefined;\n\n  // We'll be working within parentheses.\n  if (parenStart !== undefined && parenEnd !== undefined) {\n    const contents: Token[] = tokens.slice(parenStart+1, parenEnd);\n    if (contents.length === 0) {\n      // raise Exception('User Error: Parentheses cannot be empty.')\n      return undefined;\n    }\n    const contentsOperated: Token[] | undefined = performSimpleOperation(contents);\n    if (contentsOperated === undefined) {\n      // Internal Error: simple operation failed (or something).\n      return undefined;\n    }\n    // Contents operated contains single number.\n    if (contentsOperated.length === 1 && ['integer', 'float'].includes(contentsOperated[0].type)) {\n      const leftTokens = tokens.slice(0, parenStart).map((token) => ({type: token.type, value: token.value}));\n      const rightTokens = tokens.slice(parenEnd+1).map((token) => ({type: token.type, value: token.value}));\n      newTokens = leftTokens.concat(contentsOperated).concat(rightTokens);\n    } else {\n      const leftTokens = tokens.slice(0, parenStart+1).map((token) => ({type: token.type, value: token.value}));\n      const rightTokens = tokens.slice(parenEnd).map((token) => ({type: token.type, value: token.value}));\n      newTokens = leftTokens.concat(contentsOperated).concat(rightTokens);\n    }\n  // There are no parentheses remaining.\n  } else {\n    newTokens = performSimpleOperation(tokens);\n  }\n\n  if (newTokens !== undefined) {\n    newTokens = resolveNegatives(newTokens);\n  }\n  return newTokens;\n};\n\nconst evaluate = (text: string): Token[][] | undefined => {\n  let tokens = tokenize(text);\n  if (tokens === undefined) {\n    // Internal Error: Tokenize returned undefined (or something).\n    return undefined\n  }\n  tokens = establishNegatives(tokens);\n  if (tokens === undefined) {\n    // Internal Error: Establish negatives returned undefined (or something).\n    return undefined\n  }\n  tokens = resolveNegatives(tokens);\n  if (tokens === undefined) {\n    // Internal Error: Resolve negatives returned undefined (or something).\n    return undefined\n  }\n  let steps = [tokens];\n  while (steps[steps.length-1].length > 1) {\n    tokens = steps[steps.length-1];\n    tokens = performOperation(tokens);\n    if (tokens === undefined) {\n      // Internal Error: Perform operation returned undefined (or something).\n      return undefined;\n    }\n    steps.push(tokens);\n  }\n  return steps;\n};\n\nexport {\n  tokenizeLiteral,\n  tokenize,\n  establishNegatives,\n  resolveNegatives,\n  performSimpleOperation,\n  performOperation,\n  evaluate,\n  formatTokens\n};\n\n// TODO\n  // Consider refactoring tokens; it's a little redundant to have to keep checking the actual type of the number, as well as the token.type.\n  // Returns and conditionals and exceptions all over the place are leaving things a mess (especially performSimpleOperation).\n    // In theory having early returns makes it so there are guarantees down the line, but that gets messy fast.....\n  // Also idk about using \"-1\" as index default in that one place.\n  // Ya, checks and exceptions are all over the place. resolve that.\n  // ASAP make it so all these funcs can't return undefined... I'd love to remove all the narrowing for that.","import React from 'react';\nimport Input from './Input';\nimport Step from './Step';\nimport Description from './Description';\nimport {\n  // tokenizeLiteral,\n  // tokenize,\n  // establishNegatives,\n  // resolveNegatives,\n  // performSimpleOperation,\n  // performOperation,\n  evaluate,\n  formatTokens\n} from '../solve';\nimport '../styles/Solver.css';\n\nconst Solver = () => {\n  const [expression, setExpression] = React.useState(\"\");\n\n  const onInputChange = (event: React.ChangeEvent<HTMLInputElement>): void => {\n    const text = event.target.value;\n    // console.log(text);\n    setExpression(text);\n    const steps = evaluate(text);\n    if (steps !== undefined) {\n      console.log('SOLVED!')\n      steps.forEach((step) => {\n        console.log(formatTokens(step));\n      });\n    } else {\n      console.log('evaluated undefined')\n    }\n  };\n\n  return (\n    <div className='solver'>\n      <div className = 'solver-left'>\n        <Input\n          value={expression}\n          onChange={onInputChange}\n        />\n        <Description />\n        <Description />\n        <Description />\n      </div>\n      <div className='solver-middle' />\n      <div className = 'solver-right'>\n        <Step\n          initial={true}\n        />\n        <Step />\n        <Step />\n        <Step />\n      </div>\n    </div>\n  );\n};\n\nexport default Solver;\n","import React from 'react';\nimport Solver from './Solver';\nimport '../styles/App.css';\n\nconst App = () => {\n  return (\n    <div className='app'>\n      <Solver />\n    </div>\n  );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './styles/index.css';\nimport App from './components/App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}